{"name": "test_01", "status": "broken", "statusDetails": {"message": "TypeError: Object of type ObjectId is not JSON serializable", "trace": "self = <TestCase.Community.test_Community_addreport.TestCommunityaddreport object at 0x0000025E7FDF2430>\n\n    def test_01(self):\n        # 传入键key，值price，数据库名database，表名surface到MongoDB数据库\n        _paylo = MongoDBField(\"192.168.1.237\", 27017, \"community\", \"t_report\", [{}, {\"type\": 1}])\n        print(_paylo)\n        # print(MongoDBField(\"192.168.1.237\", 27017, \"community\", \"t_report\", [{}, {\"type\": 1}]))\n        # random_paylo = random.sample(_paylo, 50)\n        # paylo_data = list(map(lambda code: {\"ts\": code[0], \"code\": code[1]}, random_paylo))\n>       write_json(BASE_DIR + r\"/TestData/Communityaddreport.json\", dict(_paylo[0]))\n\ntest_Community_addreport.py:33: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n..\\..\\Common\\tools\\read_write_json.py:33: in write_json\n    json.dump(data, f, indent=2, ensure_ascii=False)  # 写为多行\nC:\\Users\\ASUS\\AppData\\Local\\Programs\\Python\\Python38\\lib\\json\\__init__.py:179: in dump\n    for chunk in iterable:\nC:\\Users\\ASUS\\AppData\\Local\\Programs\\Python\\Python38\\lib\\json\\encoder.py:431: in _iterencode\n    yield from _iterencode_dict(o, _current_indent_level)\nC:\\Users\\ASUS\\AppData\\Local\\Programs\\Python\\Python38\\lib\\json\\encoder.py:405: in _iterencode_dict\n    yield from chunks\nC:\\Users\\ASUS\\AppData\\Local\\Programs\\Python\\Python38\\lib\\json\\encoder.py:438: in _iterencode\n    o = _default(o)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <json.encoder.JSONEncoder object at 0x0000025E7FDF2B20>\no = ObjectId('5fb22c84791d040006a931fd')\n\n    def default(self, o):\n        \"\"\"Implement this method in a subclass such that it returns\n        a serializable object for ``o``, or calls the base implementation\n        (to raise a ``TypeError``).\n    \n        For example, to support arbitrary iterators, you could\n        implement default like this::\n    \n            def default(self, o):\n                try:\n                    iterable = iter(o)\n                except TypeError:\n                    pass\n                else:\n                    return list(iterable)\n                # Let the base class default method raise the TypeError\n                return JSONEncoder.default(self, o)\n    \n        \"\"\"\n>       raise TypeError(f'Object of type {o.__class__.__name__} '\n                        f'is not JSON serializable')\nE       TypeError: Object of type ObjectId is not JSON serializable\n\nC:\\Users\\ASUS\\AppData\\Local\\Programs\\Python\\Python38\\lib\\json\\encoder.py:179: TypeError"}, "start": 1608542028231, "stop": 1608542028262, "uuid": "1e80b8be-360b-4fcb-91ec-3cc08d6fc9b2", "historyId": "082abd9d6628683c6f2f810a88b33967", "testCaseId": "3bf14b9efd06d210be524a870fc43095", "fullName": "TestCase.Community.test_Community_addreport.TestCommunityaddreport#test_01", "labels": [{"name": "feature", "value": "社区_举报"}, {"name": "parentSuite", "value": "TestCase.Community"}, {"name": "suite", "value": "test_Community_addreport"}, {"name": "subSuite", "value": "TestCommunityaddreport"}, {"name": "host", "value": "DESKTOP-KBU1G8M"}, {"name": "thread", "value": "16880-MainThread"}, {"name": "framework", "value": "pytest"}, {"name": "language", "value": "cpython3"}, {"name": "package", "value": "TestCase.Community.test_Community_addreport"}]}